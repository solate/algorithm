

## 排序算法 sort

* 插入排序
* 希尔排序
* 选择排序
* 冒泡排序
* 计数排序
* 基数排序
* 归并排序
* 快速排序
* 双向扫描的快速排序
* 堆排序

### 插入排序

[insertSort.go](insertSort.go)

直接插入排序：

    直接插入排序就是从待排序列中选出一个元素，插入到已经有序的元素之中，直到所有的元素都插入到有序序列中所有的元素就全部有序了。

    通常的做法就是将第一个元素看做是有序的元素（即待排序列的第一个元素看做是有序序列），
    然后我们将第二个元素和有序序列（即第一个元素）作比较，按正确的序列插入到序列中去。
    然后在将第三个元素和前面有序序列（即整个待排序列的前两个元素）作比较，
    将第三个插入到前两个元素中去，使得前三个元素有序。以此类推，直到所有的元素都有序。


复杂度为O(n2)的排序（冒泡排序或插入排序）

### 希尔排序

[shellSort.go](shellSort.go)


希尔排序，也称递减增量排序算法，是插入排序的一种更高效的改进版本。希尔排序是非稳定排序算法。

* 插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率
* 但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位

性能提升至O(n log2 n)

也就是插入变为了步长，(有点不清楚)

让一个元素可以一次性地朝最终位置前进一大步，然后算法再取越来越小的步长进行排序，算法的最后一步就是普通的插入排序，


### 选择排序

[selectSort.go](selectSort.go)


首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。

因此对 n个元素的表进行排序总共进行至多n-1次交换。


### 冒泡排序

[bubbleSort.go](bubbleSort.go)


一次比较两个元素，如果他们的顺序错误就把他们交换过来。

冒泡排序是与插入排序拥有相等的运行时间，但是两种算法在需要的交换次数却很大地不同。
在最坏的情况，冒泡排序需要  O(n^{2})次交换，而插入排序只要最多 O(n)交换。

冒泡排序算法的运作如下：

* 比较相邻的元素。如果第一个比第二个大，就交换他们两个。
* 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。
* 针对所有的元素重复以上的步骤，除了最后一个。
* 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。