

## 排序算法 sort

* 插入排序
* 希尔排序
* 选择排序
* 冒泡排序
* 计数排序
* 基数排序
* 归并排序
* 快速排序
* 双向扫描的快速排序
* 堆排序

### 插入排序

[insertSort.go](insertSort.go)

直接插入排序：

    直接插入排序就是从待排序列中选出一个元素，插入到已经有序的元素之中，直到所有的元素都插入到有序序列中所有的元素就全部有序了。

    通常的做法就是将第一个元素看做是有序的元素（即待排序列的第一个元素看做是有序序列），
    然后我们将第二个元素和有序序列（即第一个元素）作比较，按正确的序列插入到序列中去。
    然后在将第三个元素和前面有序序列（即整个待排序列的前两个元素）作比较，
    将第三个插入到前两个元素中去，使得前三个元素有序。以此类推，直到所有的元素都有序。


复杂度为O(n2)的排序（冒泡排序或插入排序）

### 希尔排序

[shellSort.go](shellSort.go)


希尔排序，也称递减增量排序算法，是插入排序的一种更高效的改进版本。希尔排序是非稳定排序算法。

* 插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率
* 但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位

性能提升至O(n log2 n)

也就是插入变为了步长，(有点不清楚)

让一个元素可以一次性地朝最终位置前进一大步，然后算法再取越来越小的步长进行排序，算法的最后一步就是普通的插入排序，


### 选择排序

[selectSort.go](selectSort.go)


首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。

因此对 n个元素的表进行排序总共进行至多n-1次交换。


### 冒泡排序

[bubbleSort.go](bubbleSort.go)


一次比较两个元素，如果他们的顺序错误就把他们交换过来。

冒泡排序是与插入排序拥有相等的运行时间，但是两种算法在需要的交换次数却很大地不同。
在最坏的情况，冒泡排序需要  O(n^{2})次交换，而插入排序只要最多 O(n)交换。

冒泡排序算法的运作如下：

* 比较相邻的元素。如果第一个比第二个大，就交换他们两个。
* 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。
* 针对所有的元素重复以上的步骤，除了最后一个。
* 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。


### 计数排序

[countingSort.go](countingSort.go)

计数排序（Counting sort）是一种稳定的线性时间排序算法。计数排序使用一个额外的数组C ，其中第i个元素是待排序数组 A中值等于i的元素的个数。然后根据数组C 来将A中的元素排到正确的位置。


计数排序不是比较排序，排序的速度快于任何比较排序算法。

由于用来计数的数组  C 的长度取决于待排序数组中数据的范围（等于待排序数组的最大值与最小值的差加上1），这使得计数排序对于数据范围很大的数组，需要大量时间和内存

[计数排序-维基百科](https://zh.wikipedia.org/wiki/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F)
[Go数据结构与算法-计数排序](https://blog.csdn.net/yang731227/article/details/85107904)

时间复杂度为 ：O(N + max + 1)

步骤，(//TODO 不晓得为什么,暂时没查到)

* 找出待排序的数组中最大和最小的元素
* 统计数组中每个值为i的元素出现的次数，存入数组C 的第i项
* 对所有的计数累加（从C 中的第一个元素开始，每一项和前一项相加）
* 反向填充目标数组：将每个元素i放在新数组的第C[i]项，每放一个元素就将C[i]减去1